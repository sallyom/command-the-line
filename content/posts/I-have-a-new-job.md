---
title: "I Didn't Change Jobs - AI Changed the Job I Have"
date: 2025-11-18T20:00:00-05:00
draft: false
---

<p class="subtitle"><em>How the last few months quietly transformed my role as a software engineer</em></p>

Over the last few months, my role as a software developer has profoundly transformed.
I didn't negotiate a new title or adopt a new framework. Without ceremony or fanfare, the job itself simply changed.
With AI's quiet and reliable power, old workflows have become obsolete.
Not using AI stopped making sense. The ground moved beneath me.

I didn’t decide to work differently. AI became too good to ignore.
I used to write everything from scratch: a Kubernetes controller, a bash script,
a system manifest. That was the job. Today, I describe that same controller’s desired
behavior to an AI, and it generates the entire, clean codebase, complete with
scaffolding, RBAC, and tests. It’s not just generating code; it’s providing instant
access to a compressed universe of accumulated patterns and knowledge.
What's more, when the model understands the workflow, and I can give it a runner or tool access,
executing code can often become redundant. We can now bypass code entirely by delegating behavior
in plain text to an AI runner.

This isn't theory; it's my daily workflow. Every refactor, script, and debugging
session now starts with my AI partner. I still write code, but I often find myself questioning whether something should even be a
traditional codebase or whether a conversational interface with a tool-runner is sufficient. I think about where I need
determinism and where flexibility is acceptable; what deserves to be a strict function and what can be an AI-guided
workflow; what constraints the system needs and what architecture will keep it safe, predictable, and adaptable.

Another thing, I can’t prepare students or mentor junior engineers the way I used to. For the past 5 years, I've been teaching a course at Boston University,
*Software Engineering Career Prep*. I share with aspiring data and computer scientists what I do every day. This fall my class syllabus became a
moving target. The profession they're entering is already vastly different from what it was even last semester.

The old rhythm of the job, sketching ideas into code over a few days or weeks, creating tests and documentation,
wrestling with git - that world is fading. It's not gone, but it's no longer the center.
Their success won't hinge on how fast they can write, but on how well they can think, specify, and define a problem.
It always should have been this way, but the mechanics of implementing code has until now been a large factor in early career success.

Strangely enough, I firmly believe the human part of my job is getting stronger. As AI takes on more of the rogue parentheses and uneven whitespace,
the nil-pointer and race condition hunts, the repetitive boilerplate, I can imagine a world where my teammates and I spend more time actually talking.
More time imagining and designing.

When we’re less hunched over keyboards we can be more engaged with each other. When the tedious parts aren’t draining our energy,
we may have more space to explore ideas that once felt too ambitious or too time-consuming. Wild ideas feel more doable.
Innovative solutions feel closer. The ceiling feels higher.

Which is fitting, because even this post was written the same way I now build software: in conversation with my AI partner,
shaping the ideas together, clarifying them like I would with a colleague or a very patient friend.
The process even feels a little like therapy for the engineering mind: a space to think out loud, challenge assumptions,
and imagine what could be possible.

---

**This post is simply a marker in time.**

The job has changed. It changed in the last eight weeks. It changed in the few
days I've been writing this post. Avoiding AI stopped making sense. This is the
moment I realized software engineering is being rewritten. Everything that follows
starts here.

---
